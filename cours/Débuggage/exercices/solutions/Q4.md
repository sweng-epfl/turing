# Solution proposée

En exécutant le programme, vous devriez constater que l'algorithme de tri se bloque, car les limites
ne sont pas correctement vérifiées. En utilisant le débogueur, vous devriez être capable d'identifier que les bornes de la méthode
`_sort` ne sont pas correctes. En effet, la précondition est que le tableau trié commence à l'index
`frm` et se termine à l'index `until - 1`. Cependant, ceci n'est pas vérifié dans le cas de base.

Après avoir corrigé le bug, vous devriez pouvoir exécuter le programme et voir que l'algorithme de tri
lance une `RecursionError`. C'est parce que l'algorithme est récursif, mais n'a pas de cas de base.
Ici, le pivot n'est pas correctement choisi, et l'algorithme récursive sur le même sous-tableau.

Enfin, la méthode `_partition` ne déplace pas le pivot à la bonne position. En effet, il y a
une erreur de type "off-by-one" après la boucle qui déplace le pivot à la bonne position. L'inspection de la mémoire
à ce stade de l'exécution devrait vous aider à identifier le bug.

Voici des implémentations corrigées des méthodes `sort` et `partition` :

```java
@staticmethod
def _sort(elements, comparator, frm, until):
    if frm == until: # BUG 1 : condition de fin incorrecte
        return
    pivot = Quicksort._partition(elements, comparator, frm, until)
    Quicksort._sort(elements, comparator, frm, pivot)
    Quicksort._sort(elements, comparator, pivot + 1, until) # BUG 2 : `+ 1` manquant

@staticmethod
def _partition(elements, comparator, frm, until):
    p = elements[frm]
    s = until
    for i in range(until - 1, frm, -1):
        if comparator(elements[i], p) > 0:
            s -= 1
            elements[i], elements[s] = elements[s], elements[i]
    elements[frm], elements[s-1] = elements[s-1], elements[frm] # BUG 3 : décalage incorrect
    return s - 1
```
